# Shell 外部命令执行支持

## 概述

NexaOS 的 shell 现在支持从标准系统路径执行外部命令，类似于传统的 Unix shell（如 bash 和 sh）。这使得可以直接从 shell 提示符运行编译的二进制文件，如 `nslookup`、`login` 和其他工具。

## 实现细节

### 添加到 Shell 的系统调用

以下系统调用被添加到 `userspace/shell.rs`：

```rust
const SYS_FORK: u64 = 57;      // 创建子进程
const SYS_EXECVE: u64 = 59;    // 执行程序
const SYS_WAIT4: u64 = 61;     // 等待子进程结束

fn fork() -> i32;
fn execve(path: *const u8, argv: *const *const u8, envp: *const *const u8) -> i32;
fn wait4(pid: i32, status: *mut i32, options: i32) -> i32;
```

### PATH 搜索

Shell 按以下顺序在这些目录中搜索可执行文件：

1. `/bin` - 用户命令
2. `/sbin` - 系统命令
3. `/usr/bin` - 扩展用户命令
4. `/usr/sbin` - 扩展系统命令

### 核心函数

#### `file_exists(path: &str) -> bool`

使用 `SYS_STAT` 系统调用检查文件是否存在。

#### `find_executable(cmd: &str) -> Option<[u8; MAX_PATH]>`

在标准 PATH 目录中搜索可执行文件。如果找到，返回完整路径的空字符结尾字节数组。

**搜索逻辑**:
1. 遍历 PATH 目录列表（`/bin`, `/sbin`, `/usr/bin`, `/usr/sbin`）
2. 构建完整路径：`/dir/command`
3. 使用 `file_exists()` 检查文件
4. 返回第一个找到的匹配项

#### `execute_external_command(cmd: &str, args: &[&str]) -> bool`

主要执行函数，执行以下步骤：

1. **搜索可执行文件**: 调用 `find_executable()` 在 PATH 中查找
2. **准备参数数组**: 构建 argv（命令 + 参数 + NULL 终止符）
3. **Fork 进程**: 创建子进程
4. **子进程**: 通过 `execve` 执行命令
5. **父进程**: 通过 `wait4` 等待子进程完成

### 命令处理器修改

`handle_command()` 的默认分支从：

```rust
_ => {
    println_str("Unknown command");
}
```

改为：

```rust
_ => {
    // 尝试作为外部命令执行
    let args: std::vec::Vec<&str> = parts.collect();
    if !execute_external_command(cmd, &args) {
        // execute_external_command 已经打印了错误消息（如果命令未找到）
    }
}
```

## 使用示例

启动 NexaOS 并登录后，可以运行外部命令：

### 基本命令执行

```bash
# 运行 nslookup（DNS 查询工具）
nslookup google.com

# 运行 login（用户认证）
login testuser

# 运行 /bin 或 /sbin 中的任何二进制文件
<命令> [参数...]
```

### 内置命令仍然有效

内置命令（如 `ls`、`cd`、`cat`、`pwd` 等）继续正常工作，并且优先于外部命令。

**内置命令列表**:
- `help` - 显示帮助
- `pwd` - 显示当前目录
- `cd` - 更改目录
- `ls` - 列出文件
- `cat` - 显示文件内容
- `echo` - 打印文本
- `mkdir` - 创建目录
- `stat` - 显示文件统计信息
- `whoami` - 显示当前用户
- `clear` - 清屏
- `exit` - 退出 shell

### 命令未找到

如果命令既不是内置命令，也不在 PATH 中找到，shell 会显示：

```
Command not found: <命令>
```

## 测试

### 在 QEMU 中手动测试

1. **构建完整系统**:
   ```bash
   ./scripts/build-all.sh
   ```

2. **在 QEMU 中运行**:
   ```bash
   ./scripts/run-qemu.sh
   ```

3. **启动后登录，尝试**:
   ```bash
   # 测试 DNS 查询
   nslookup google.com
   
   # 测试用户认证
   login testuser
   
   # 列出 /bin 中的可执行文件
   ls /bin
   ```

4. Shell 应该从 `/bin/nslookup` 执行 nslookup 二进制文件。

### 预期行为

| 情况 | 行为 |
|------|------|
| **命令找到** | 外部程序执行，产生输出，程序退出后 shell 返回到提示符 |
| **命令未找到** | 显示错误消息 "Command not found: <命令>" |
| **执行失败** | 显示适当的错误消息（"fork failed"、"execve failed"、"wait failed"） |
| **内置命令** | 直接执行，不搜索 PATH |

### 自动化测试脚本

创建测试脚本 `test-external-commands.sh`:

```bash
#!/bin/bash
# 测试外部命令执行

echo "=== 测试 1: 运行 nslookup ==="
echo "nslookup google.com" | timeout 5 ./scripts/run-qemu.sh

echo ""
echo "=== 测试 2: 命令未找到 ==="
echo "nonexistent_command" | timeout 5 ./scripts/run-qemu.sh

echo ""
echo "=== 测试 3: 内置命令优先级 ==="
echo -e "ls\npwd\ncd /bin\npwd" | timeout 5 ./scripts/run-qemu.sh
```

## 架构流程

```
用户输入: "nslookup google.com"
         │
         ▼
   ┌──────────────┐
   │ handle_command│
   │ (解析命令)    │
   └──────┬───────┘
          │
          │ 不是内置命令？
          ▼
   ┌─────────────────────┐
   │ execute_external_cmd │
   └──────┬──────────────┘
          │
          │ 步骤 1: find_executable("nslookup")
          │         搜索: /bin → /sbin → /usr/bin → /usr/sbin
          │         找到: "/bin/nslookup"
          ▼
    ┌──────────┐
    │  fork()  │ ──────┐ 创建子进程
    └──────────┘       │
          │            │
          ├────────────┴─────────────┐
          │                          │
    ┌─────▼─────┐            ┌──────▼─────┐
    │  父进程   │            │   子进程   │
    │ (Shell)   │            │            │
    └─────┬─────┘            └──────┬─────┘
          │                         │
          │                         │ 步骤 2: 准备参数
          │                         │ argv[0] = "nslookup"
          │                         │ argv[1] = "google.com"
          │                         │ argv[2] = NULL
          │                         │
          │                         │ 步骤 3: execve("/bin/nslookup", argv, envp)
          │                         │ → 替换进程映像
          │                         ▼
          │                  ┌──────────────┐
          │                  │   nslookup   │
          │                  │   程序运行   │
          │                  │   执行查询   │
          │                  │   打印结果   │
          │                  └──────┬───────┘
          │                         │
          │ 步骤 4: wait4(pid)     │ 程序完成后退出
          │    等待子进程          │ exit(0)
          │◄────────────────────────┘
          │
          │ 步骤 5: 返回 shell 提示符
          ▼
   ┌────────────┐
   │   提示符   │
   │  user@..$ │
   └────────────┘
```

## 限制

### 当前实现的限制

1. **无环境变量**: `envp` 数组为空。命令无法访问环境变量如 `$PATH`、`$HOME` 等。
2. **固定 PATH**: 搜索路径是硬编码的，用户无法修改。
3. **无 shell 脚本功能**: 不支持管道（`|`）、重定向（`>`、`<`）或后台执行（`&`）。
4. **参数限制**: 最多 31 个参数，每个最多 63 个字符。
5. **不搜索当前目录**: 出于安全原因，不搜索 `.`（当前目录）。
6. **无通配符扩展**: `*`、`?` 等不会展开。
7. **无命令替换**: `` `command` `` 或 `$(command)` 不支持。

### 未来增强功能

待未来迭代添加：

1. **环境变量**: 实现 `getenv`、`setenv` 系统调用和环境块管理
2. **PATH 配置**: 允许用户通过环境或配置文件设置自定义 PATH
3. **std::process::Command 支持**: 提供完整的 Rust std API 兼容性用于进程生成
4. **Shell 功能**: 添加管道、重定向、作业控制、后台进程
5. **可执行权限检查**: 在尝试运行前检查文件权限（执行位）
6. **二进制格式检测**: 检测并拒绝非可执行文件
7. **错误码传播**: 传播子进程的退出状态给 shell
8. **信号处理**: 处理 Ctrl+C、Ctrl+Z 等信号

## 相关文件

### 修改的文件

| 文件 | 变更 | 说明 |
|------|------|------|
| `userspace/shell.rs` | 添加外部命令执行支持 | 新增 fork/execve/wait4 包装器，find_executable 和 execute_external_command 函数 |
| `scripts/build-rootfs.sh` | 暂时禁用 udp_test 构建 | udp_test.rs 文件缺失，构建时被注释掉 |

### 系统调用实现

此功能使用的系统调用已在内核中实现：

- `src/syscall.rs`: 系统调用分发器
  - `SYS_FORK` (57): 创建子进程
  - `SYS_EXECVE` (59): 执行新程序
  - `SYS_WAIT4` (61): 等待子进程状态变化

- `src/process.rs`: 进程管理
  - 进程创建、调度、终止
  - ELF 加载器
  - 进程表管理

### 用户空间库

这些系统调用也在 `nrlib` 中包装，供其他程序使用：

- `userspace/nrlib/src/lib.rs`: 
  - `fork()` - 行 589
  - `execve()` - 行 594
  - `wait4()` - 行 603

## 故障排除

### "Command not found" 但二进制文件存在

**诊断步骤**:

1. 检查二进制文件是否在搜索路径中：
   ```bash
   ls /bin
   ls /sbin
   ls /usr/bin
   ls /usr/sbin
   ```

2. 验证二进制文件可执行：
   ```bash
   stat /bin/<命令>
   ```

3. 检查文件名是否完全匹配（区分大小写）

**可能原因**:
- 文件在非标准路径（如 `/usr/local/bin`）
- 文件名拼写错误
- 文件被删除或未包含在 rootfs 中

### "fork failed"

**可能原因**:
- 内核进程表已满
- 内存不足无法创建新进程
- 达到进程限制

**调试**:
```bash
# 检查当前进程数（如果 ps 可用）
ps aux

# 检查内核日志
dmesg | grep -i "fork\|process"
```

### "execve failed"

**可能原因**:
- 二进制文件不是有效的 ELF 文件
- 二进制文件架构错误（不是 x86_64）
- 二进制文件需要 rootfs 中不存在的动态库
- 内存不足无法加载程序

**诊断**:
```bash
# 检查文件类型
file /bin/<命令>

# 检查 ELF 头
readelf -h /bin/<命令>

# 检查动态库依赖（如果支持）
ldd /bin/<命令>
```

### "wait failed"

**说明**: wait4 实现中的内核错误

**调试**:
- 检查内核日志获取详细信息
- 可能是内核 bug，需要查看 `src/syscall.rs` 和 `src/process.rs`

## 性能考虑

外部命令执行涉及：

1. **系统调用开销**: 3 次系统调用（fork、execve、wait4）
   - 每次系统调用：~1-10 μs
   - 总开销：~3-30 μs

2. **进程创建**: 内核分配新进程结构、页表、文件描述符
   - 内存分配：~100-500 μs
   - 页表设置：~50-200 μs

3. **二进制加载**: 内核解析 ELF 头，将段加载到内存
   - ELF 解析：~10-50 μs
   - 内存映射：~100-500 μs（取决于程序大小）

4. **上下文切换**: 最少 2 次切换（父→子，子→父）
   - 每次切换：~1-5 μs
   - 总开销：~2-10 μs

**总估计时间**: ~300-1500 μs（0.3-1.5 ms）

**优化建议**:
- 对于频繁使用的命令，考虑实现为内置 shell 命令以避免此开销
- 对于多个命令，考虑批处理执行
- 使用 `posix_spawn` 而不是 `fork + execve`（更高效）

## 安全考虑

### 当前安全措施

1. **PATH 顺序重要**: 
   - `/bin` 中的命令在 `/sbin` 之前检查
   - 防止 PATH 注入攻击

2. **PATH 中无当前目录**: 
   - 不搜索 `.`（当前目录）
   - 防止意外执行用户目录中的恶意二进制文件

3. **空字符终止**: 
   - 所有传递给内核的字符串都正确空字符终止
   - 防止缓冲区溢出

4. **参数限制**: 
   - 固定大小数组防止无限内存使用
   - 最多 31 个参数，每个最多 63 字符

5. **无相对路径执行**:
   - 只搜索绝对路径
   - 防止目录遍历攻击

### 未来安全增强

应包括：

1. **可执行权限检查**: 验证文件的执行位
2. **二进制签名验证**: 验证二进制文件的加密签名
3. **沙箱/能力限制**: 限制进程可以执行的操作
4. **资源限制**: CPU 时间、内存、打开文件数
5. **审计日志**: 记录所有命令执行用于安全审计
6. **SELinux/AppArmor 支持**: 强制访问控制

## 与 std::process::Command 的关系

Rust 的 `std::process::Command` API 在底层使用相同的系统调用（fork/execve/wait）。

**当前状态**:
- ✅ 底层系统调用已实现（fork、execve、wait4）
- ✅ Shell 可以执行外部命令
- ⏳ std::process::Command 应该可以工作，但未在 NexaOS 上测试
- ⏳ 可能需要 nrlib 中的额外 libc 兼容性

**测试 std::process::Command**:

创建测试程序 `userspace/test_command.rs`:

```rust
#![no_std]
#![no_main]

use std::process::Command;

pub fn main() {
    println!("Testing std::process::Command...");
    
    let output = Command::new("/bin/nslookup")
        .arg("google.com")
        .output()
        .expect("Failed to execute nslookup");
    
    println!("Exit status: {}", output.status);
    println!("Output: {}", String::from_utf8_lossy(&output.stdout));
}
```

**预期工作**:
- `Command::new()` 应该工作
- `arg()` 应该工作
- `spawn()` / `output()` 应该使用 fork/execve
- `wait()` 应该使用 wait4

## 示例程序

### 简单的命令执行器

```rust
// userspace/exec_demo.rs
#![no_std]
#![no_main]

extern crate nrlib;

use nrlib::{fork, execve, wait4, println_str, exit};

pub fn main() {
    println_str("Executing /bin/nslookup...");
    
    let pid = fork();
    if pid < 0 {
        println_str("Fork failed!");
        exit(1);
    }
    
    if pid == 0 {
        // 子进程
        let path = b"/bin/nslookup\0";
        let argv = [
            b"nslookup\0".as_ptr(),
            b"google.com\0".as_ptr(),
            core::ptr::null(),
        ];
        let envp = [core::ptr::null(); 1];
        
        execve(path.as_ptr(), argv.as_ptr(), envp.as_ptr());
        println_str("Execve failed!");
        exit(1);
    }
    
    // 父进程
    let mut status = 0;
    wait4(pid, &mut status, 0);
    println_str("Command completed.");
    exit(0);
}
```

---

**状态**: ✅ 已实现并测试  
**版本**: NexaOS v0.1  
**最后更新**: 2024-11-16  
**作者**: NexaOS 开发团队
