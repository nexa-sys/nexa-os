# NexaOS 动态链接支持

## 概述

NexaOS 现已支持通过 PT_INTERP 机制加载动态链接的可执行文件。本文档描述实现细节、当前状态和未来工作。

## 实现内容

### 内核端支持

#### ELF 加载器增强 (`src/elf.rs`)

为 ELF 加载器添加了以下方法：

1. **`has_interpreter()`**: 检查 ELF 文件是否有 PT_INTERP 段
2. **`get_interpreter()`**: 从 PT_INTERP 段提取解释器路径（通常是 `/lib64/ld-linux-x86-64.so.2`）

这些方法扫描程序头，查找 `PhType::Interp` 段并提取以 null 结尾的解释器路径字符串。

#### 进程加载 (`src/process.rs`)

`Process::from_elf()` 函数已修改为：

1. 检查可执行文件是否有 PT_INTERP 段
2. 如果存在，尝试从文件系统加载解释器
3. 将原始程序加载到其期望的地址（0x400000）
4. 将动态链接器加载到单独的位置（0xA00000）
5. 执行解释器的入口点而不是程序的入口点
6. 如果找不到解释器，则回退到静态链接

### 动态链接器可用性

系统在以下位置包含主机的动态链接器（`ld-linux-x86-64.so.2`）：
- **Initramfs**: `/lib64/ld-linux-x86-64.so.2`（用于早期启动程序）
- **Rootfs**: `/lib64/ld-linux-x86-64.so.2`（用于常规程序）

这是通过以下构建脚本在构建过程中添加的：
- `scripts/build-userspace.sh`（initramfs）
- `scripts/build-rootfs.sh`（rootfs）

## 当前状态

### 已实现的功能

✅ **PT_INTERP 检测**: 内核可以检测动态链接的可执行文件
✅ **解释器加载**: 内核加载动态链接器而不是程序
✅ **独立内存区域**: 程序和解释器加载到不同的内存位置
✅ **文件系统集成**: 动态链接器在 initramfs 和 rootfs 中都可用
✅ **静态二进制回退**: 静态可执行文件继续像以前一样工作
✅ **辅助向量传递**: 内核在用户栈上构造 `argc/argv/envp`，并提供 `AT_PHDR/AT_PHENT/AT_PHNUM/AT_BASE/AT_ENTRY/AT_RANDOM/AT_EXECFN` 等关键信息
✅ **程序与解释器双加载**: 原始程序和解释器都会按期望的虚拟地址装载，并在堆栈中暴露给动态链接器

### 缺少的功能

❌ **共享库**: 不支持加载共享库（`.so` 文件）
❌ **符号解析**: 没有运行时符号解析或重定位处理
❌ **GOT/PLT 支持**: 不支持全局偏移表或过程链接表

## 动态链接应该如何工作

### 完整流程

1. **内核加载程序**：
   - 解析 ELF 头并找到 PT_INTERP 段
   - 在合适的地址加载解释器（`ld-linux.so`）
   - 在其请求的虚拟地址加载原始程序
   - 在堆栈上设置辅助向量，包含程序信息
   - 将控制权转移到解释器的入口点

2. **解释器执行**：
   - 读取辅助向量以查找程序信息
   - 解析程序的 PT_DYNAMIC 段
   - 加载所需的共享库（来自 DT_NEEDED 条目）
   - 执行重定位（DT_RELA、DT_REL）
   - 解析符号（DT_SYMTAB、DT_STRTAB）
   - 初始化库（DT_INIT、DT_INIT_ARRAY）
   - 将控制权转移到程序的入口点

3. **程序运行**：
   - 通过 PLT/GOT 访问库函数
   - 如果配置了延迟绑定，动态链接器处理延迟绑定

### 所需的辅助向量

内核应该在用户堆栈上传递这些：

```c
AT_PHDR    = 3   // 程序头地址
AT_PHENT   = 4   // 程序头条目大小
AT_PHNUM   = 5   // 程序头数量
AT_PAGESZ  = 6   // 系统页面大小
AT_BASE    = 7   // 解释器基地址
AT_FLAGS   = 8   // 标志
AT_ENTRY   = 9   // 程序入口点
AT_UID     = 11  // 真实用户 ID
AT_EUID    = 12  // 有效用户 ID
AT_GID     = 13  // 真实组 ID
AT_EGID    = 14  // 有效组 ID
```

## 测试动态链接

### 创建测试程序

```bash
# 创建一个简单的动态链接程序
cat > test_dynamic.c << 'EOF'
#include <stdio.h>
int main() {
    printf("Hello from dynamic program!\n");
    return 0;
}
EOF

gcc test_dynamic.c -o test_dynamic

# 验证它是动态链接的
readelf -l test_dynamic | grep INTERP
# 应该显示：[Requesting program interpreter: /lib64/ld-linux-x86-64.so.2]
```

### 当前行为

当加载动态链接的程序时：
1. 内核检测到 PT_INTERP 段
2. 内核加载动态链接器
3. 内核为用户栈写入 `argc/argv/envp` 及所需辅助向量
4. ⚠️ **链接器仍然失败**，因为缺少共享库加载与重定位支持

### 预期行为

在内核向链接器传递适当的辅助向量后，程序应该成功执行。

## 未来工作

### 阶段 1：共享库与重定位（高优先级）

- 在内核端暴露加载 `.so` 所需的文件系统接口
- 扩展动态链接器路径搜索策略（`DT_NEEDED`、`RPATH/RUNPATH`）
- 支持 `DT_RELA/DT_REL` 表重定位及符号解析（`SYMTAB/STRTAB`）

### 阶段 2：内存布局（高优先级）

将解释器和程序都加载到内存中：
- 解释器在固定基址（例如，0x7000_0000_0000）
- 程序在其请求的虚拟地址
- 使用适当的权限映射两者

### 阶段 3：共享库支持（中等优先级）

添加文件系统支持：
- `/lib64/*.so` - 64 位共享库
- `/lib/*.so` - 32 位共享库（可选）

### 阶段 4：自定义动态链接器（低优先级）

可选地实现一个最小的 NexaOS 特定动态链接器：
- 更好地与内核集成
- 减小大小和复杂性
- 自定义安全功能

## 架构考虑

### 使用动态链接的内存布局

```
┌────────────────────────┐ 0x7FFF_FFFF_FFFF
│      用户堆栈          │
├────────────────────────┤ 0x7000_0000_0000（建议）
│  动态链接器            │
│  (ld-linux.so)         │
├────────────────────────┤ 0x1000_0000_0000
│  共享库                │
│  (.so 文件)            │
├────────────────────────┤ 0x0040_0000（当前 USER_VIRT_BASE）
│  程序文本/数据         │
└────────────────────────┘ 0x0000_0000_0000
```

### 安全考虑

- **ASLR**：考虑地址空间布局随机化以提高安全性
- **RELRO**：支持只读重定位
- **BIND_NOW**：强制立即绑定而不是延迟绑定
- **DT_RUNPATH**：限制库搜索路径

## 参考资料

- [ELF 规范](https://refspecs.linuxfoundation.org/elf/elf.pdf)
- [System V ABI](https://refspecs.linuxfoundation.org/elf/x86_64-abi-0.99.pdf)
- [ld.so(8) 手册](https://man7.org/linux/man-pages/man8/ld.so.8.html)
- [辅助向量](https://lwn.net/Articles/519085/)

## 总结

当前实现通过以下方式为动态链接提供了基础：
1. 检测动态链接的可执行文件
2. 加载动态链接器
3. 在文件系统中包含链接器
4. 为解释器提供完整的辅助向量和栈初始状态

要完全支持动态链接的程序，仍需补齐共享库加载、重定位以及符号解析等能力。
