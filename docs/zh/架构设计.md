# NexaOS 架构设计文档

> **状态**: 生产级混合内核操作系统  
> **标准**: POSIX.1-2017, Unix语义  
> **目标**: x86_64 架构  
> **最后更新**: 2024

## 目录

1. [快速概览](#快速概览)
2. [混合内核设计](#混合内核设计)
3. [启动流程](#启动流程)
4. [内存架构](#内存架构)
5. [进程管理](#进程管理)
6. [系统调用接口](#系统调用接口)
7. [文件系统架构](#文件系统架构)
8. [安全模型](#安全模型)
9. [驱动程序框架](#驱动程序框架)
10. [进程间通信 (IPC)](#进程间通信-ipc)
11. [同步原语](#同步原语)
12. [性能特性](#性能特性)

---

## 快速概览

NexaOS 是一个**生产级混合内核操作系统**，结合了：
- 单内核的**性能**（关键路径在内核空间）
- 微内核的**模块性**（可选服务在用户空间）
- 能力系统的**安全性**（Ring 0/Ring 3 隔离）
- POSIX.1-2017 和 Unix 语义的**兼容性**

### 关键指标
- **内核大小**: ~2-50MB (调试/发布版)
- **启动时间**: ~2-5 秒到 shell 提示符
- **内存布局**: 256TB 用户空间 (0x0-0x400000000000), 128TB 内核空间 (0xffffffff80000000-0xffffffffffffffff)
- **进程数限制**: 硬件相关（已测试 1000+ PIDs）
- **系统调用**: 38+ 已实现，完全 POSIX 兼容

---

## 混合内核设计

### 架构分类

NexaOS 实现了**真正的混合内核**，而不是纯粹的微内核或单内核：

```
                    ┌──────────────────────────────────┐
                    │      用户空间 (Ring 3)           │
        ┌───────────┼──────────────┬──────────────────┤
        │           │              │                  │
    ┌─────────┐ ┌────────────┐ ┌────────────┐ ┌────────────┐
    │   Init  │ │   Shell    │ │ Auth/IPC   │ │ 服务      │
    │ 服务    │ │  实用程序  │ │   服务    │ │ (可选)    │
    └─────────┘ └────────────┘ └────────────┘ └────────────┘
        │           │              │                  │
        └───────────┼──────────────┴──────────────────┘
                    │ 系统调用接口 (38+ 系统调用)
        ┌───────────┼──────────────────────────────────┐
        │           │                                  │
    ┌─────────────────────────────────────────────────┐
    │      内核空间 (Ring 0) - 128TB                  │
    ├─────────────────────────────────────────────────┤
    │                                                 │
    │  ┌────────────┐  ┌────────────┐  ┌───────────┐ │
    │  │  内存管理  │  │ 调度和进程 │  │ 中断处理  │ │
    │  │  (分页)    │  │   管理     │  │           │ │
    │  └────────────┘  └────────────┘  └───────────┘ │
    │                                                 │
    │  ┌────────────┐  ┌────────────┐  ┌───────────┐ │
    │  │ VFS/inode  │  │ 信号管理   │  │    IPC    │ │
    │  │ + ext2 fs  │  │ & 身份认证 │  │  队列     │ │
    │  └────────────┘  └────────────┘  └───────────┘ │
    │                                                 │
    │  ┌────────────────────────────────────────────┐ │
    │  │   驱动程序 (LAPIC, E1000, 等)            │ │
    │  └────────────────────────────────────────────┘ │
    │                                                 │
    └─────────────────────────────────────────────────┘
        │                                              │
        └──────────────────┬───────────────────────────┘
                           │ 直接内存/端口 I/O
        ┌──────────────────┴───────────────────────────┐
        │                                              │
    ┌─────────────────────────────────────────────────┐
    │      硬件 (x86_64 CPU, RAM, 设备)              │
    └─────────────────────────────────────────────────┘
```

### 设计决策

| 方面 | 选择 | 理由 |
|------|------|------|
| **内核方式** | 单内核核心 + 可选用户空间服务 | 关键路径性能，扩展时模块性 |
| **进程模型** | Unix 风格 fork/exec | POSIX 兼容，熟悉的语义 |
| **内存模型** | 每进程虚拟地址空间 | 隔离、安全、大地址空间 |
| **调度** | 优先级轮转 | 简洁、公平、实时支持 |
| **IPC** | 管道、信号、队列 | POSIX 标准、成熟、经过验证 |
| **文件系统** | 双重 (initramfs + ext2 运行时) | 快速启动 (RAM)，持久存储 (磁盘) |
| **驱动模型** | 关键驱动内核，其他可选 | 性能与安全平衡 |

---

## 启动流程

### 6 阶段启动过程

```
阶段 1: UEFI/Multiboot2 加载程序
    ↓ (引导程序 → kernel.elf)
阶段 2: 长模式设置 (16位 → 32位 → 64位)
    ↓ (GDT, 分页, 保护模式)
阶段 3: 早期内核初始化
    ↓ (内存分配器, 串行日志, 中断处理)
阶段 4: 内核运行环境
    ↓ (调度器, 进程管理, 系统服务)
阶段 5: Init 进程启动
    ↓ (用户空间 init 生成服务)
阶段 6: 交互式 Shell
    ↓ (用户命令提示符准备就绪)
```

### 详细阶段进展

| 阶段 | 组件 | 任务 | 输出 |
|------|------|------|------|
| 1 | 引导程序 | 加载内核、initramfs、传递启动信息 | `[BOOT] Multiboot2 info loaded` |
| 2 | 分页设置 | 长模式、虚拟寻址、内核映射 | `[BOOT] Paging enabled` |
| 3 | 内核初始化 | 内存分配器、GDT、中断、串行 | `[BOOT] Kernel initialized` |
| 4 | 运行时 | 调度器启动、进程表准备 | `[BOOT] Scheduling enabled` |
| 5 | Init 执行 | `/init` 生成 (PID 1) | `[INIT] Starting init process` |
| 6 | Shell 提示符 | 登录/交互式 shell 准备 | `login:` 提示符 |

---

## 内存架构

### 虚拟地址空间布局

```
用户空间 (Ring 3):
  0x0000000000000000 ┌──────────────────────────┐
                     │  用户程序 (text/data)    │  0-1GB
  0x0000000040000000 ├──────────────────────────┤
                     │  堆 (动态)               │  1-256GB
  0x0000400000000000 ├──────────────────────────┤
                     │  栈 (共享 mmap)          │  256-256TB
  0x0400000000000000 └──────────────────────────┘
                     
                     [未映射间隙 - 保护页]

内核空间 (Ring 0):
  0xffffffff80000000 ┌──────────────────────────┐
                     │  内核 Text/Data          │  2GB (恒等映射)
  0xffffffff82200000 ├──────────────────────────┤
                     │  内核堆 (vmalloc)        │  1GB
  0xffffffff83400000 ├──────────────────────────┤
                     │  直接映射 (RAM 1:1)      │  ~50GB
  0xffffffff84000000 ├──────────────────────────┤
                     │  中断/系统调用           │  共享内核内存
  0xffffffffffffffff └──────────────────────────┘
```

### 分页设置

**活跃文件**: `src/paging.rs`, `src/process.rs`

```rust
// 内核内存恒等映射 (虚拟 == 物理)
// 用户空间进程有隔离的页表 (每进程 CR3)
// 转换: 虚拟 → 物理 via 多级页表 (x86_64 上 4 级)

// src/process.rs 中的关键常数:
USER_BASE = 0x0000000000000000              // 用户空间起始
KERNEL_BASE = 0xffffffff80000000           // 内核空间起始
HEAP_BASE = 0x0000000100000000             // 用户堆起始
STACK_BASE = 0x0000400000000000            // 用户栈向下增长
```

### 内存保护

- **用户 ↔ 内核**: CPU 强制 Ring 0/3 边界
- **进程 ↔ 进程**: 每进程隔离页表
- **保护页**: 用户/内核空间之间的未映射区域
- **栈溢出**: 通过保护页错误检测

---

## 进程管理

### ProcessState 生命周期

```
               ┌────────────┐
               │  创建      │  (fork, 新创建)
               └──────┬─────┘
                      │
                      v
               ┌────────────┐
         ┌────→│  就绪      │←────┐  (在调度器队列中)
         │     └──────┬─────┘     │
         │            │           │
         │ (超时)    v (运行)     │ (让出)
         │     ┌────────────┐     │
         └─────│  运行      │─────┘
               └──────┬─────┘
                      │
         (I/O, 信号)  │  (阻塞)
                      v
               ┌────────────┐
               │  阻塞      │  (等待 I/O、信号等)
               └──────┬─────┘
                      │
         (I/O 就绪)  │  (信号投递)
                      v
               ┌────────────┐
               │  就绪      │  (回到队列)
               └────────────┘
                      
               (退出)
                      v
               ┌────────────┐
               │  已退出    │  (等待父进程回收)
               └────────────┘
```

### 进程结构

**文件**: `src/process.rs`

```rust
pub struct Process {
    pub pid: u32,                                    // 进程 ID
    pub ppid: u32,                                   // 父进程 PID
    pub state: ProcessState,                         // 当前状态
    pub page_table: PhysicalAddress,                 // CR3 - 用户空间根表
    pub registers: InterruptFrame,                   // 保存的寄存器
    pub memory: ProcessMemory { heap_ptr, stack_ptr }, // 内存布局
    pub files: [FileDescriptor; 256],               // 打开的文件描述符
    pub signal_handlers: [SignalHandler; 64],       // 信号处理程序
    pub pgroup: u32,                                // 进程组
    pub credentials: Credentials { uid, gid },      // 用户/组 ID
    pub exit_code: Option<i32>,                     // 退出状态
}
```

### 调度器

**文件**: `src/scheduler.rs`

- **算法**: 优先级轮转
- **时间量子**: 每进程 10ms
- **优先级**: 0-39 (0=最高, 39=最低)
- **抢占**: 计时器中断驱动 (10ms)
- **负载均衡**: 单核简单队列 (多核通过 SMP 子系统)

```
就绪队列结构:
┌─────────────────────────────────────────┐
│  优先级 0 (实时)                        │
│  [进程 A]←→[进程 B]←→[进程 C]           │
├─────────────────────────────────────────┤
│  优先级 5 (普通)                        │
│  [进程 D]←→[进程 E]                     │
├─────────────────────────────────────────┤
│  优先级 39 (空闲)                       │
│  [空闲进程]                             │
└─────────────────────────────────────────┘
      ↓
   调度器选择最高优先级就绪进程
```

---

## 系统调用接口

### 系统调用机制

**文件**: `src/syscall.rs`, `src/interrupts/`

```
用户程序
    ↓
syscall(数字, 参数1-6)  [nrlib 中的用户空间包装]
    ↓
SYSCALL 指令  (x86_64 快速系统调用)
    ↓
内核处理程序: syscall_handler()
    ↓
┌─────────────────────────┐
│ 分配器 (匹配 syscall 数字)
├─────────────────────────┤
│ sys_read/write/open/... │
│ sys_fork/exec/exit      │
│ sys_signal/kill/pause   │
│ sys_pipe/dup/fcntl      │
│ sys_*other (38+)        │
└─────────────────────────┘
    ↓
执行处理程序逻辑
    ↓
返回值在 RAX 中
    ↓
SYSRET 指令
    ↓
用户程序恢复 (RIP = RCX)
```

### 已实现的系统调用 (38+)

**进程控制**: fork, exec, execve, exit, wait, waitpid, pause, getpid, getppid, setpgid, getpgid, 等.

**文件操作**: open, close, read, write, lseek, stat, fstat, chdir, getcwd, mkdir, rmdir, unlink, 等.

**IPC**: pipe, dup, dup2, fcntl, poll, select, signal, sigaction, kill, sigprocmask, 等.

**内存**: mmap, munmap, brk, mprotect, 等.

**用户/组**: getuid, geteuid, getgid, getegid, setuid, setgid, getgroups, 等.

**其他**: uname, time, gettimeofday, 等.

---

## 文件系统架构

### 双文件系统策略

```
启动/运行时:
┌─────────────────────────┐
│  Initramfs (CPIO)       │  <- 只读, 在 RAM 中
│  (由引导程序加载)       │  <- 在启动阶段 3 解析
└────────────────┬────────┘   <- 包含 /init, /lib64/ld-linux.so
                 │
        ┌────────v────────┐
        │ 阶段 4 内核     │
        │  运行时 (VFS)   │  <- 内存副本
        └────────┬────────┘
                 │
        ┌────────v──────────────┐
        │ 阶段 5: 挂载 ext2     │
        │ rootfs.ext2 从磁盘    │
        └────────┬──────────────┘
                 │
        ┌────────v────────────┐
        │ 完整文件系统        │  <- 动态、持久化
        │ (所有标准目录)      │  <- 读/写操作
        └─────────────────────┘
```

### VFS 操作

**文件**: `src/fs.rs`

```rust
pub trait FileSystem {
    fn open(&mut self, path: &str, flags: u32) -> Result<Inode>;
    fn close(&mut self, fd: usize) -> Result<()>;
    fn read(&mut self, fd: usize, buf: &mut [u8]) -> Result<usize>;
    fn write(&mut self, fd: usize, data: &[u8]) -> Result<usize>;
    fn stat(&mut self, path: &str) -> Result<Stat>;
    fn readdir(&mut self, path: &str) -> Result<Vec<DirEntry>>;
    fn mkdir(&mut self, path: &str, mode: u32) -> Result<()>;
    fn unlink(&mut self, path: &str) -> Result<()>;
    fn chmod(&mut self, path: &str, mode: u32) -> Result<()>;
}
```

### Initramfs 解析

**文件**: `src/initramfs.rs`

- **格式**: CPIO newc (ASCII cpio 归档格式)
- **加载**: 由引导程序在内存地址加载 (通过 Multiboot2 传递)
- **解析**: 在启动阶段 3 发生
- **内容**: `/init` (内核, 静态链接), `/lib64/ld-linux.so` (动态链接器), 引导实用程序
- **挂载为**: 只读 `/` 直到 ext2 rootfs 替换

---

## 安全模型

### 特权级别

```
Ring 3 (用户)
  ├─ 可执行: 大多数指令 (无特权操作)
  ├─ 可访问: 仅自己的内存页
  ├─ 不能: MSR, CR3, 中断处理程序, 端口 I/O
  └─ 保护: MMU 验证所有内存访问

        │ 系统调用 (syscall/int 0x80)
        ↓

Ring 0 (内核)
  ├─ 可执行: 所有指令 (特权操作启用)
  ├─ 可访问: 所有内存页 (无限制)
  ├─ 可用: CR3, MSR, I/O 端口
  ├─ 责任: 验证所有用户参数
  └─ 返回: SYSRET 到用户，结果清理
```

### 身份认证和授权

**文件**: `src/auth.rs`

- **用户 ID**: UID (0-65535), GID (0-65535)
- **能力**: UID 0 (root) 具有所有能力
- **限制**:
  - 非 root 不能改变他人拥有的文件
  - 非 root 不能执行 setuid 程序
  - 非 root 不能访问权限不足的文件
- **组**: 用于访问控制的补充组

### 信号处理

**文件**: `src/signal.rs`

```rust
// 信号是异步通知
// 每个进程有信号处理程序 (信号动作, 阻塞掩码)

pub struct SignalHandler {
    pub action: SignalAction,  // SIG_DFL, SIG_IGN, 或自定义处理程序
    pub flags: SignalFlags,    // SA_RESTART, SA_NOCLDSTOP, 等
    pub mask: SignalMask,      // 此处理程序期间阻塞的信号
}

// 信号投递:
// 1. 查找目标进程
// 2. 检查信号是否被阻塞 (sigprocmask)
// 3. 查找处理程序
// 4. 如果自定义处理程序: 调用 (上下文已保存)
// 5. 如果 SIG_DFL: 执行默认动作 (终止、忽略、停止、继续)
// 6. 恢复上下文
```

---

## 驱动程序框架

### 驱动模型

```
物理设备
    ↓
驱动程序模块 (例如 e1000 网络驱动程序)
    ├─ 探测/初始化: 检测硬件, 分配资源
    ├─ 中断处理程序: 处理设备中断
    ├─ 读/写操作: 提交请求, 轮询状态
    └─ 清理: 卸载时释放资源

    ↓ (目前在内核中, 还没有可加载模块支持)

VFS/字符/块设备抽象
    ├─ /dev/eth0 (网络设备)
    ├─ /dev/disk0 (块设备)
    └─ /dev/serial (串行设备)

系统调用接口 (read, write, ioctl, 等)
    ↓
用户应用程序
```

### 已实现的驱动程序

- **E1000 NIC**: 千兆网络驱动程序 (接收/传输)
- **LAPIC**: 本地 APIC 用于定时器和 IPI
- **Serial**: 串行端口输出 (调试)
- **Keyboard**: PS/2 键盘输入
- **Ext2**: 文件系统驱动程序 (读/写)

---

## 进程间通信 (IPC)

### 管道/FIFO

**文件**: `src/pipe.rs`

```rust
struct Pipe {
    buffer: [u8; 4096],      // 循环缓冲区
    read_index: usize,       // 读指针
    write_index: usize,      // 写指针
    readers: u32,            // 打开的读处理
    writers: u32,            // 打开的写处理
    lock: Mutex,             // 同步
}

// 操作:
// - read(): 如果为空则阻塞 (读者在条件变量上等待)
// - write(): 如果满则阻塞 (写者在条件变量上等待)
// - EOF: 当所有写者关闭时
```

### 信号

**文件**: `src/signal.rs`

- **异步通知**: 由内核投递的信号
- **处理程序**: 自定义信号处理程序或默认动作
- **掩蔽**: 进程可以阻塞信号 (sigprocmask)
- **实时信号**: 信号队列 (尚未实现)

### 消息队列 (未来)

计划在后续版本中实现 (目前未实现)。

---

## 同步原语

### 自旋锁

**文件**: `src/safety/`

```rust
pub struct SpinLock<T> {
    locked: AtomicBool,     // 0=解锁, 1=锁定
    data: UnsafeCell<T>,
}

impl<T> SpinLock<T> {
    pub fn lock(&self) -> LockGuard<T> {
        // 旋转直到原子比较交换成功
        loop {
            if self.locked.compare_exchange(false, true, Acquire, Relaxed).is_ok() {
                break;  // 获取锁
            }
            // 让出 CPU 时间 (cpu::pause() 或类似)
        }
        LockGuard { lock: self }
    }
}
```

### 条件变量

```rust
pub struct CondVar {
    waiter_count: AtomicUsize,
    waiting_processes: VecQueue<ProcessId>,  // 阻塞的进程
}

impl CondVar {
    pub fn wait(&self, lock: &mut SpinLock) {
        // 1. 将自己添加到等待队列
        // 2. 释放锁
        // 3. 阻塞 (调度器从就绪队列中移除)
    }
    
    pub fn notify_one(&self) {
        // 1. 从队列中移除一个等待者
        // 2. 标记为就绪
    }
    
    pub fn notify_all(&self) {
        // 1. 从队列中移除所有等待者
        // 2. 将所有标记为就绪
    }
}
```

---

## 性能特性

### 优化技术

1. **快速系统调用**: SYSCALL/SYSRET (x86_64) 而不是 INT 0x80
2. **恒等映射**: 内核空间直接映射 (无 TLB 缺失)
3. **TLB 局部性**: 进程切换仅使 TLB 中的用户条目失效
4. **中断批处理**: 组合多个 I/O 完成
5. **内存预分配**: 固定分配器池 (无碎片)

### 基准目标

| 操作 | 目标 | 方法 |
|------|------|------|
| 进程创建 (fork) | <1ms | 内核页表克隆 |
| 系统调用延迟 | <5μs | 快速路径, 最小验证 |
| 上下文切换 | <10μs | 最小寄存器保存/恢复 |
| 管道吞吐量 | >100MB/s | 零复制设计 (如果可能) |
| 中断延迟 | <100μs | 最小处理程序开销 |

### 可伸缩性

- **单核**: 完整功能，已测试最多 1000 个 PID
- **多核 (SMP)**: 每 CPU 调度队列，无锁数据结构
- **内存**: 已测试最多 50GB RAM (虚拟化)

---

## 调试和可观测性

### 串行日志

**文件**: `src/serial.rs`

```rust
// 通过串行端口的调试输出
kinfo!("进程 {} 生成", pid);           // INFO 级别
kerror!("系统调用 {} 失败", syscall);  // ERROR 级别
kfatal!("内存不足!");                   // FATAL - 触发 panic
```

**输出**: 通过 `./scripts/run-qemu.sh` 使用 `-serial mon:stdio` 捕获

### 内核追踪 (未来)

- **事件日志**: 记录关键转换 (尚未暴露给用户空间)
- **追踪点**: 用于检测的战略位置
- **性能计数器**: CPU 事件计数 (通过 perf 子系统)

---

## 常见修改

### 添加系统调用

1. 在 `src/syscall.rs` 中定义系统调用号和处理程序
2. 在 `userspace/nrlib/` 中添加用户空间包装
3. 实现处理程序逻辑 (验证、操作、返回)
4. 使用用户空间程序测试
5. 更新 `docs/en/SYSCALL-REFERENCE.md`

### 添加驱动程序

1. 在 `src/` 或 `src/drivers/` 中创建驱动程序模块
2. 实现中断处理程序和 I/O 操作
3. 向设备管理器注册
4. 添加 `/dev/` 节点创建到 init
5. 使用用户空间工具测试

### 扩展内存布局

1. 在 `src/process.rs` 中更新内存映射常数
2. 在 `src/paging.rs` 中更新分页设置
3. 重新构建内核: `cargo build --release --target x86_64-nexaos.json`
4. 测试: `./scripts/run-qemu.sh`

---

## 相关文档

- [快速参考](../en/QUICK-REFERENCE.md) - 命令和系统调用
- [构建系统](../en/BUILD-SYSTEM.md) - 编译和部署
- [系统调用参考](../en/SYSCALL-REFERENCE.md) - 详细系统调用文档
- [内核日志](../en/kernel-logging-system.md) - 调试输出系统
- [动态链接](../en/DYNAMIC_LINKING.md) - 运行时链接详情
- [英文: 系统概览](../en/SYSTEM-OVERVIEW.md) - 英文系统概览
- [英文: 架构设计](../en/ARCHITECTURE.md) - 英文架构设计

---

## FAQ

**Q: NexaOS 与 Linux 有何不同？**
A: NexaOS 具有更简单的架构（没有像 netfilter 这样的复杂子系统）、POSIX 兼容性重点和教育性设计。Linux 是具有数十年优化的生产级系统。

**Q: 我能在 NexaOS 上运行 Linux 二进制文件吗？**
A: 部分 - 静态链接的二进制文件可以工作；动态链接的二进制文件需要兼容的 glibc/musl（目前支持有限）。

**Q: 如何调试内核崩溃？**
A: 检查串行输出 (`./scripts/run-qemu.sh` 捕获), 查找栈追踪, 在文档中搜索错误消息。

**Q: 最大进程数是多少？**
A: 取决于可用内存用于内核结构 (~每个进程在内核中 1KB)。已测试 1000+ PID。

---

## 词汇表

- **VFS**: 虚拟文件系统 (文件系统实现的抽象)
- **系统调用**: 系统调用 (用户空间对内核的请求)
- **Ring 0/3**: CPU 特权级别 (内核/用户)
- **TLB**: 转换后备缓冲区 (CPU 内存缓存)
- **Inode**: 文件元数据和位置
- **管道**: 进程间通信 (FIFO 队列)
- **信号**: 对进程的异步通知
- **上下文切换**: 在调度期间保存/恢复进程状态

---

**最后更新**: 2024-01-15  
**维护者**: NexaOS 开发团队  
**许可证**: 与 NexaOS 内核相同
