# execve General Protection Fault Bug

## Symptom

When running an external command from the shell (e.g., `nslookup`), the following occurs:

```
root@nexa:/$ nslookup
execve failed
root@nexa:GP 0000000000000000 ...
```

Followed by a General Protection (GP) fault with register dump showing `RIP=0000000000000000`.

## Root Cause Analysis

### Issue 1: argv/envp Ignored by Kernel

The `syscall_execve` function in `src/syscall.rs` completely ignores the `argv` and `envp` parameters:

```rust
fn syscall_execve(path: *const u8, _argv: *const *const u8, _envp: *const *const u8) -> u64 {
    // ...
    // _argv and _envp are never used!
}
```

The `Process::from_elf()` function uses a hardcoded `DEFAULT_ARGV0` instead of the actual arguments passed from user space.

### Issue 2: RIP = 0 Indicates Entry Point Problem

The GP fault with `RIP=0000000000000000` suggests:

1. The entry point in the new process is 0 (null pointer)
2. OR the execve is partially replacing the process but leaving it in an invalid state
3. OR the stack is corrupted and returning to address 0

### Issue 3: execve Implementation is Incomplete

Current `execve` implementation:
- ‚úÖ Reads the path string
- ‚úÖ Loads ELF file from filesystem
- ‚úÖ Creates new Process from ELF
- ‚úÖ Replaces current process image
- ‚ùå Does NOT process argv from user space
- ‚ùå Does NOT process envp from user space
- ‚ùå May not properly handle process replacement in all cases

## Debug Information Needed

To diagnose the exact cause, we need to add logging to:

1. `syscall_execve` - Log the path being executed
2. `Process::from_elf` - Log the entry point and stack pointer
3. Shell's `execute_external_command` - Log the path before calling execve
4. Kernel's execve handler - Log before and after process replacement

## Immediate Fix Plan

### Phase 1: Add Debug Logging (Current)

Add extensive logging to trace execution flow:

```rust
// In execute_external_command
print_str("Attempting to execute: ");
println_str(path_as_str);
print_str("fork returned: ");
print_i32(pid);
println_str("");
```

### Phase 2: Fix argv/envp Handling

Modify `syscall_execve` to:
1. Read argv array from user space
2. Read envp array from user space
3. Pass these to `Process::from_elf` or `build_initial_stack`

### Phase 3: Fix Process Replacement

Ensure that when execve replaces a process:
1. The new entry point is valid (not 0)
2. The stack is properly set up
3. All registers are correctly initialized
4. The process state is consistent

## Workaround

Until argv/envp support is implemented, programs can still be executed but will not receive command-line arguments or environment variables.

## Related Code Locations

- `userspace/shell.rs`: `execute_external_command()` - Lines ~1497-1577
- `src/syscall.rs`: `syscall_execve()` - Lines 1413-1520
- `src/process.rs`: `Process::from_elf()` - Lines 133-250
- `src/process.rs`: `build_initial_stack()` - Lines 378-480

## Test Case

Simple test to reproduce:

```bash
# In QEMU after booting
root@nexa:/$ ls /bin
nslookup udp_test sh login

root@nexa:/$ nslookup
# Should execute but currently triggers GP fault
```

## Status

- üî¥ **Critical Bug**: Prevents external command execution
- ‚è≥ **In Progress**: Adding debug logging
- üìù **Next**: Implement argv/envp support in execve

---

**Date**: 2024-11-16  
**Priority**: P0 (Critical - blocks basic shell functionality)  
**Assignee**: Development Team
